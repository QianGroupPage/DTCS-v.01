"""
Firetasks for parsing VASP outputs

# TODO(Andrew)
"""

import datetime
import json
import os

from atomate.utils.utils import env_chk, get_logger
from atomate.vasp.database import VaspCalcDb
from fireworks.utilities.fw_serializers import DATETIME_HANDLER
from fireworks import FiretaskBase, FWAction, explicit_serialize
import pymongo

__author__ = 'Andrew Bogdan'
__email__ = 'andrewbogdan@lbl.gov'

_logger = get_logger(__name__)


@explicit_serialize
class CoreEigenToDb(FiretaskBase):
    """
    Aggregate the core eigenvalues for many species (each one with its own
    VASP runs) into one database.

    In order for this task to find your tasks, you need to set
    core_eigen_calc_index in the additional_fields of VaspToDb. This lets
    CoreEigenToDb know which species is which, as often the chemical formula
    is not sufficient identification.

    Required Parameters:
        calc_count (int): The number of species you're calculating core
            eigenenergies for.
        db_file (str): Path to the db.json file which points to the database
            with your tasks collection and where you want your core_eigen
            collection.
        wf_uuid (str): The unique ID of the workflow, used to identify which
            tasks to trawl. Usually auto-generated by get_wf_...().

    Optional Parameters:
        wf_meta (str): Additional workflow metadata besides the wf_uuid.
    """

    JSON_DUMP_FILE = 'core_eigen.json'

    required_params = ['calc_count', 'db_file', 'wf_uuid']
    optional_params = ['wf_meta']

    def run_task(self, fw_spec):

        _logger.info('Retrieving core eigenenergies from VASP output.')

        # Retrieve parameters
        calc_count = self.get('calc_count')
        db_file = env_chk(self.get('db_file'), fw_spec)
        wf_uuid = self.get('wf_uuid')
        wf_meta = self.get('wf_meta', {'wf_uuid': wf_uuid})

        # Retrieve the information about each run (in particular, core
        #  level eigenenergies) from the database.
        mmdb = VaspCalcDb.from_db_file(db_file, admin=True)

        # For each core eigen calculation, create a profile of the most
        #  up-to-date run (a task) of that calculation.
        task_outputs = []
        for calc_index in range(calc_count):
            task = mmdb.collection.find_one(
                filter={
                    'wf_meta.wf_uuid': wf_uuid,
                    'core_eigen_calc_index': calc_index,
                },
                sort=[('last_updated', pymongo.DESCENDING)],
            )

            outcar = task['calcs_reversed'][0]['output']['outcar']

            task_profile = {
                'chemsys': task['chemsys'],
                'core_energies': outcar['core_state_eigen'],
                'formula_pretty': task['formula_pretty'],
                'formula_reduced_abc': task['formula_reduced_abc'],
                'last_updated': task['last_updated'],
                'nelements': task['nelements'],
                'nsites': task['nsites'],
                'task_id': task['task_id'],
            }
            task_outputs.append(task_profile)

        # Make the output collection
        out_dict = {
            'last_updated': datetime.datetime.utcnow(),
            'task_outputs': task_outputs,
            'ntasks': calc_count,
            'wf_meta': wf_meta,
        }

        # Store the results in the database or a JSON file
        if not db_file:
            _logger.info(f'Firetask {self.__name__}: '
                         f'No database file found, attempting to dump to '
                         f'{os.path.join(os.getcwd(), self.JSON_DUMP_FILE)}.')
            with open(self.JSON_DUMP_FILE, 'w') as file:
                json.dumps(obj=out_dict,
                           fp=file,
                           default=DATETIME_HANDLER, )
        else:
            mmdb.db['core_eigen'].insert_one(out_dict)

        _logger.info('Core eigenenergies successfully retrieved.')

        return FWAction()
